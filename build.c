#include "action.h"
#include "config.h"
#include "error.h"
#include "lemon.h"
#include "rule.h"
#include "set.h"
#include "state.h"
#include "symbol.h"

#include <assert.h>
#include <stdlib.h>

/* forward declarations */
static void buildshifts(struct lemon *, struct state *);
static struct state *get_state(struct lemon *, struct config_list **basis);
static int resolve_conflict(struct action *, struct action *);
static int same_symbol(struct symbol *, struct symbol *);
static void check_config_list(struct lemon *lemp, struct config_list *list);

/* Compute the reduce actions, and resolve conflicts. */
void
FindActions(struct lemon *lemp) {
  int i, j;
  struct config_list *cfp;
  struct symbol *sp;
  struct rule_list *rp;

  /* Add all of the reduce actions
   * A reduce action is added for each element of the followset of
   * a configuration which has its dot at the extreme right.
   */
  for (i = 0; i < lemp->nstate; i++) { /* Loop over all states */
    struct state *stp;
    stp = lemp->sorted[i];
    for (cfp = stp->configs; cfp; cfp = cfp->next) { /* Loop over all configurations */
      if (cfp->item->rule->nrhs == cfp->item->position) {   /* Is dot at extreme right? */
        for (j = 0; j < lemp->nterminal; j++) {
          if (SetFind(cfp->item->fws, j)) {
            /* Add a reduce action to the state "stp" which will reduce by the
             * rule "cfp->rp" if the lookahead symbol is "lemp->symbols[j]" */
            action_list_insert(make_action(lemp->symbols[j], REDUCE, cfp->item->rule), &stp->actions);
            // TODO: check rewrite Action_add(&stp->ap, REDUCE, lemp->symbols[j], (char *)cfp->rp);
          }
        }
      }
    }
  }

  /* Add the accepting token */
  if (lemp->start) {
    sp = lookup_symbol(lemp->start);
    if (sp == 0)
      sp = lemp->rules->item->lhs;
  } else {
    sp = lemp->rules->item->lhs;
  }
  /* Add to the first state (which is always the starting state of the
   * finite state machine) an action to ACCEPT if the lookahead is the
   * start nonterminal.
   */
  action_list_insert(make_action(sp, ACCEPT, 0), &lemp->sorted[0]->actions);
  // TODO: check rewrite Action_add(&lemp->sorted[0]->ap, ACCEPT, sp, 0);

  /* Resolve conflicts */
  for (i = 0; i < lemp->nstate; i++) {
    struct action_list *ap, *nap;
    struct state *stp;
    stp = lemp->sorted[i];
    action_list_sort(&stp->actions);
    for (ap = stp->actions; ap && ap->next; ap = ap->next) {
      for (nap = ap->next; nap && nap->item->sp == ap->item->sp; nap = nap->next) {
        /* The two actions "ap->item" and "nap->item" have the same lookahead.
         * Figure out which one should be used
         */
        lemp->nconflict += resolve_conflict(ap->item, nap->item);
      }
    }
  }

  /* Report an error for each rule that can never be reduced. */
  for (rp = lemp->rules; rp; rp = rp->next)
    rp->item->canReduce = false;
  for (i = 0; i < lemp->nstate; i++) {
    struct action_list *ap;
    for (ap = lemp->sorted[i]->actions; ap; ap = ap->next) {
      if (ap->item->type == REDUCE)
        ap->item->x.rp->canReduce = true;
    }
  }
  for (rp = lemp->rules; rp; rp = rp->next) {
    if (rp->item->canReduce)
      continue;
    ErrorMsg(lemp, rp->item->ruleline, "This rule can not be reduced.\n");
  }
}

/* Find all nonterminals which will generate the empty string.
 * Then go back and compute the first sets of every nonterminal.
 * The first set is the set of all terminal symbols which can begin
 * a string generated by that nonterminal.
 */
void
FindFirstSets(struct lemon *lemp) {
  int i, j;
  struct rule_list *rp;
  int progress;

  for (i = 0; i < lemp->nsymbol; i++) {
    lemp->symbols[i]->lambda = false;
  }
  for (i = lemp->nterminal; i < lemp->nsymbol; i++) {
    lemp->symbols[i]->firstset = SetNew();
  }

  /* First compute all lambdas */
  do {
    progress = 0;
    for (rp = lemp->rules; rp; rp = rp->next) {
      if (rp->item->lhs->lambda)
        continue;
      for (i = 0; i < rp->item->nrhs; i++) {
        struct symbol *sp = rp->item->rhs[i];
        assert(sp->type == NONTERMINAL || sp->lambda == false);
        if (sp->lambda == false)
          break;
      }
      if (i == rp->item->nrhs) {
        rp->item->lhs->lambda = true;
        progress = 1;
      }
    }
  } while (progress);

  /* Now compute all first sets */
  do {
    struct symbol *s1, *s2;
    progress = 0;
    for (rp = lemp->rules; rp; rp = rp->next) {
      s1 = rp->item->lhs;
      for (i = 0; i < rp->item->nrhs; i++) {
        s2 = rp->item->rhs[i];
        if (s2->type == TERMINAL) {
          progress += SetAdd(s1->firstset, s2->index);
          break;
        } else if (s2->type == MULTITERMINAL) {
          for (j = 0; j < s2->nsubsym; j++) {
            progress += SetAdd(s1->firstset, s2->subsym[j]->index);
          }
          break;
        } else if (s1 == s2) {
          if (s1->lambda == false)
            break;
        } else {
          progress += SetUnion(s1->firstset, s2->firstset);
          if (s2->lambda == false)
            break;
        }
      }
    }
  } while (progress);
  return;
}

/* Compute all followsets.
 *
 * A followset is the set of all symbols which can come immediately
 * after a configuration.
 */
void
FindFollowSets(struct lemon *lemp) {
  int i;
  struct config_list *cfp;
  struct config_list *plp;
  int progress;
  int change;

  for (i = 0; i < lemp->nstate; i++) {
    for (cfp = lemp->sorted[i]->configs; cfp; cfp = cfp->next) {
      cfp->item->status = INCOMPLETE;
    }
  }

  do {
    progress = 0;
    for (i = 0; i < lemp->nstate; i++) {
      for (cfp = lemp->sorted[i]->configs; cfp; cfp = cfp->next) {
        if (cfp->item->status == COMPLETE)
          continue;
        for (plp = cfp->item->fplp; plp; plp = plp->next) {
          change = SetUnion(plp->item->fws, cfp->item->fws);
          if (change) {
            plp->item->status = INCOMPLETE;
            progress = 1;
          }
        }
        cfp->item->status = COMPLETE;
      }
    }
  } while (progress);
}

/* Construct the propagation links */
void
FindLinks(struct lemon *lemp) {
  int i;
  struct config_list *cfp;
  struct config *other;
  struct state *stp;
  struct config_list *plp;

  /* Housekeeping detail:
   * Add to every propagate link a pointer back to the state to
   * which the link is attached.
   */
  for (i = 0; i < lemp->nstate; i++) {
    stp = lemp->sorted[i];
    for (cfp = stp->configs; cfp; cfp = cfp->next) {
      cfp->item->stp = stp;
    }
  }

  /* Convert all backlinks into forward links.  Only the forward
   * links are used in the follow-set computation.
   */
  for (i = 0; i < lemp->nstate; i++) {
    stp = lemp->sorted[i];
    for (cfp = stp->configs; cfp; cfp = cfp->next) {
      for (plp = cfp->item->bplp; plp; plp = plp->next) {
        other = plp->item;
        other->fplp = config_list_insert(cfp->item, &other->fplp);
      }
    }
  }
}

/* Find a precedence symbol of every rule in the grammar.
 *
 * Those rules which have a precedence symbol coded in the input
 * grammar using the "[symbol]" construct will already have the
 * rp->precsym field filled.  Other rules take as their precedence
 * symbol the first RHS symbol with a defined precedence.  If there
 * are not RHS symbols with a defined precedence, the precedence
 * symbol field is left blank.
 */
void
FindRulePrecedences(struct lemon *lemp) {
  struct rule_list *rp;
  for (rp = lemp->rules; rp; rp = rp->next) {
    if (rp->item->precsym == 0) {
      int i, j;
      for (i = 0; i < rp->item->nrhs && rp->item->precsym == 0; i++) {
        struct symbol *sp = rp->item->rhs[i];
        if (sp->type == MULTITERMINAL) {
          for (j = 0; j < sp->nsubsym; j++) {
            if (sp->subsym[j]->prec >= 0) {
              rp->item->precsym = sp->subsym[j];
              break;
            }
          }
        } else if (sp->prec >= 0) {
          rp->item->precsym = rp->item->rhs[i];
        }
      }
    }
  }
}

/* Compute all LR(0) states for the grammar.  Links
 * are added to between some states so that the LR(1) follow sets
 * can be computed later.
 */
void
FindStates(struct lemon *lemp) {
  struct symbol *sp;
  struct rule_list *rp;

  /* Find the start symbol */
  if (lemp->start) {
    sp = lookup_symbol(lemp->start);
    if (sp == 0) {
      ErrorMsg(lemp, 0,
               "The specified start symbol \"%s\" is not \
                    in a nonterminal of the grammar.  \"%s\" will be used as the start \
                    symbol instead.",
               lemp->start, lemp->rules->item->lhs->name);
      sp = lemp->rules->item->lhs;
    }
  } else {
    sp = lemp->rules->item->lhs;
  }

  /* Make sure the start symbol doesn't occur on the right-hand side of
   * any rule.  Report an error if it does.  (YACC would generate a new
   * start symbol in this case.)
   */
  for (rp = lemp->rules; rp; rp = rp->next) {
    int i;
    for (i = 0; i < rp->item->nrhs; i++) {
      if (rp->item->rhs[i] == sp) { /* FIX ME:  Deal with multiterminals */
        ErrorMsg(lemp, 0,
                 "The start symbol \"%s\" occurs on the \
                        right-hand side of a rule. This will result in a parser which \
                        does not work properly.",
                 sp->name);
      }
    }
  }

  /* The basis configuration set for the first state
   * is all rules which have the start symbol as their
   * left-hand side
   */
  struct config_list *state_config_list = NULL;
  for (rp = sp->rules; rp; rp = rp->next) {
    struct config *new_config;
    rp->item->lhsStart = 1;
    new_config = make_config(rp->item, 0);
    SetAdd(new_config->fws, 0);
    state_config_list = config_list_insert(new_config, &state_config_list);
  }

  /* Compute the first state.  All other states will be
   * computed automatically during the computation of the first one.
   * The returned pointer to the first state is not used.
   */
  (void)get_state(lemp, &state_config_list);
  return;
}

/* Construct all successor states to the given state.  A "successor"
 * state is any state which can be reached by a shift action.
 */
static void
buildshifts(struct lemon *lemp, struct state *stp) {
  struct config_list *cfp;  // For looping thru the config closure of "stp"
  struct config_list *bcfp; // For the inner loop on config closure of "stp"
  struct config_list *new_cl = NULL;
  struct config *newcfg;
  struct symbol *sp;    // Symbol following the dot in configuration "cfp"
  struct symbol *bsp;   // Symbol following the dot in configuration "bcfp"
  struct state *newstp; // A pointer to a successor state

  /* Each configuration becomes complete after it contibutes to a successor
   * state.  Initially, all configurations are incomplete
   */
  for (cfp = stp->configs; cfp; cfp = cfp->next)
    cfp->item->status = INCOMPLETE;

  /* Loop through all configurations of the state "stp" */
  for (cfp = stp->configs; cfp; cfp = cfp->next) {
    if (cfp->item->status == COMPLETE)
      continue; // Already used by inner loop
    if (cfp->item->position >= cfp->item->rule->nrhs)
      continue;                              // Can't shift this config
    sp = cfp->item->rule->rhs[cfp->item->position]; // Symbol after the dot

    /* For every configuration in the state "stp" which has the symbol "sp"
     * following its dot, add the same configuration to the basis set under
     * construction but with the dot shifted one symbol to the right.
     */
    for (bcfp = cfp; bcfp; bcfp = bcfp->next) {
      if (bcfp->item->status == COMPLETE)
        continue; /* Already used */
      if (bcfp->item->position >= bcfp->item->rule->nrhs)
        continue;                                 /* Can't shift this one */
      bsp = bcfp->item->rule->rhs[bcfp->item->position]; /* Get symbol after dot */
      if (!same_symbol(bsp, sp))
        continue;                    /* Must be same as for "cfp" */
      bcfp->item->status = COMPLETE; /* Mark this config as used */
      newcfg = make_config(bcfp->item->rule, bcfp->item->position + 1);
      newcfg->bplp = config_list_insert(bcfp->item, &newcfg->bplp);
      new_cl = config_list_insert(newcfg, &new_cl);
    }

    /* Get a pointer to the state described by the basis configuration set
     * constructed in the preceding loop
     */
    newstp = get_state(lemp, &new_cl);

    /* The state "newstp" is reached from the state "stp" by a shift action
     * on the symbol "sp"
     */
    if (sp->type == MULTITERMINAL) {
      int i;
      for (i = 0; i < sp->nsubsym; i++) {
        action_list_insert(make_action(sp->subsym[i], SHIFT, newstp), &stp->actions);
        // TODO: check rewrite Action_add(&stp->ap, SHIFT, sp->subsym[i], (char *)newstp);
      }
    } else {
      action_list_insert(make_action(sp, SHIFT, newstp), &stp->actions);
      // TODO: check rewrite Action_add(&stp->ap, SHIFT, sp, (char *)newstp);
    }
  }
}

/* Return a pointer to a state which is described by the configuration.*/
static struct state *
get_state(struct lemon *lemp, struct config_list **basis) {
  struct state *stp;

  /* Sort basis of the new state. */
  config_list_sort(basis);
  stp = lookup_state(*basis);
  if (stp) {
    /* A state with the same basis already exists!  Copy all the follow-set
     * propagation links from the state under construction into the
     * preexisting state, then resymbolturn a pointer to the preexisting state
     */
    struct config_list *x;
    struct config_list const *y;
    for (x = *basis, y = stp->basis; x && y; x = x->next, y = y->next) {
      y->item->bplp = config_list_copy(&y->item->bplp, x->item->bplp);
      clear_config_list(x->item->fplp);
      x->item->fplp = x->item->bplp = 0;
    }
  } else {
    /* This really is a new state.  Construct all the details */
    check_config_list(lemp, *basis);
    stp = make_state(*basis);       // A new state structure
    stp->statenum = lemp->nstate++; // Every state gets a sequence number
    buildshifts(lemp, stp);         // Recursively compute successor states
  }
  return stp;
}

static void
check_config_list(struct lemon *lemp, struct config_list *list) {
  for (; list; list = list->next) {
    struct rule *rule = list->item->rule;
    struct symbol *symbol = rule->rhs[list->item->position];
    if (symbol->type == NONTERMINAL) {
      if (symbol->rules == 0 && symbol != lemp->errsym) {
        ErrorMsg(lemp, rule->line, "Nonterminal \"%s\" has no rules.", symbol->name);
      }
    }
  }
}

/* Resolve a conflict between the two given actions.  If the
 * conflict can't be resolved, return non-zero.
 *
 * NO LONGER TRUE:
 *   To resolve a conflict, first look to see if either action
 *   is on an error rule.  In that case, take the action which
 *   is not associated with the error rule.  If neither or both
 *   actions are associated with an error rule, then try to
 *   use precedence to resolve the conflict.
 *
 * If either action is a SHIFT, then it must be apx.  This
 * function won't work if apx->type==REDUCE and apy->type==SHIFT.
 */
static int
resolve_conflict(struct action *apx, struct action *apy) {
  struct symbol *spx, *spy;
  int errcnt = 0;
  assert(apx->sp == apy->sp); // Otherwise there would be no conflict
  if (apx->type == SHIFT && apy->type == SHIFT) {
    apy->type = SSCONFLICT;
    errcnt++;
  }
  if (apx->type == SHIFT && apy->type == REDUCE) {
    spx = apx->sp;
    spy = apy->x.rp->precsym;
    if (spy == 0 || spx->prec < 0 || spy->prec < 0) {
      /* Not enough precedence information. */
      apy->type = SRCONFLICT;
      errcnt++;
    } else if (spx->prec > spy->prec) { // higher precedence wins
      apy->type = RD_RESOLVED;
    } else if (spx->prec < spy->prec) {
      apx->type = SH_RESOLVED;
    } else if (spx->prec == spy->prec && spx->assoc == RIGHT) { // Use operator
      apy->type = RD_RESOLVED;                                  // associativity
    } else if (spx->prec == spy->prec && spx->assoc == LEFT) {  // to break tie
      apx->type = SH_RESOLVED;
    } else {
      assert(spx->prec == spy->prec && spx->assoc == NONE);
      apx->type = ERROR;
    }
  } else if (apx->type == REDUCE && apy->type == REDUCE) {
    spx = apx->x.rp->precsym;
    spy = apy->x.rp->precsym;
    if (spx == 0 || spy == 0 || spx->prec < 0 || spy->prec < 0 || spx->prec == spy->prec) {
      apy->type = RRCONFLICT;
      errcnt++;
    } else if (spx->prec > spy->prec) {
      apy->type = RD_RESOLVED;
    } else if (spx->prec < spy->prec) {
      apx->type = RD_RESOLVED;
    }
  } else {
    assert(apx->type == SH_RESOLVED || apx->type == RD_RESOLVED || apx->type == SSCONFLICT || apx->type == SRCONFLICT ||
           apx->type == RRCONFLICT || apy->type == SH_RESOLVED || apy->type == RD_RESOLVED || apy->type == SSCONFLICT ||
           apy->type == SRCONFLICT || apy->type == RRCONFLICT);
    /* The REDUCE/SHIFT case cannot happen because SHIFTs come before
     * REDUCEs on the list.  If we reach this point it must be because
     * the parser conflict had already been resolved.
     */
  }
  return errcnt;
}

/* Return true if two symbols are the same. */
static int
same_symbol(struct symbol *a, struct symbol *b) {
  int i;
  if (a == b)
    return 1;
  if (a->type != MULTITERMINAL)
    return 0;
  if (b->type != MULTITERMINAL)
    return 0;
  if (a->nsubsym != b->nsubsym)
    return 0;
  for (i = 0; i < a->nsubsym; i++) {
    if (a->subsym[i] != b->subsym[i])
      return 0;
  }
  return 1;
}
